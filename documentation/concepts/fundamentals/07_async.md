---
id: async 
title: 非同期プログラミングモデル
sidebar_label: 非同期プログラミングモデル
---
`finalize` モデルは、プログラムの前半をオフチェーンで、後半をオンチェーンで実行する新しいハイブリッド型プログラミングモデルとして導入されました。しかしこのモデルには、コードの finalize 順序を制御できないなどの課題がありました。

たとえば関数 `A` が `B` を呼び、その後 `C` を呼ぶ場合、実際の finalize 順序はオフチェーン側の処理完了順 (`B`, `C`, `A` など) に依存してしまいます。

より表現力の高いプログラムを実現するために、`finalize` モデルは廃止され、代わりに `async/await` モデルが導入されました。このモデルは他プログラミング言語の非同期モデルを踏襲しつつ、Aleo ブロックチェーン特有の制約を備えています。非同期プログラミングに慣れた開発者であれば、Leo における実装も直感的に理解できるでしょう。

`async/await` モデルの詳細は[こちら](https://docs.leo-lang.org/guides/async)に掲載されています。

大まかには、オンチェーンで実行されるコードは値を直接返さない非同期コードであり、代わりに `Future` を返します。`Future` は直列実行はもちろん、より複雑な制御フローにも組み合わせ可能です。

`async/await` モデルのルールは以下のとおりです。
- 非同期関数は `async transition` からのみ呼び出せます。
- 非同期関数は値を返せません。
- 非同期トランジションは条件分岐ブロック内から呼び出せません。
- 非同期関数呼び出しは、後で実行されるコードを表す `Future` を返します。
- 非同期トランジション呼び出しはオプションの値と、後で実行されるコードを表す 1 つの `Future` を返さなければなりません。
- 非同期トランジション呼び出しで生成された `Future` をそのまま返すことはできません。
- `Future` は非同期関数呼び出しへ渡すことができ、必ず `await` する必要があります。
- 生成されたすべての `Future` は、非同期関数で消費するか、出力として返却する必要があります。
