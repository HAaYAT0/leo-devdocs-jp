---
id: consensus 
title: コンセンサス
sidebar_label: コンセンサス
---

## 概要
Aleo ネットワークは、ブロック確定を即時ファイナリティで実現する安全かつ堅牢なコンセンサス機構として [AleoBFT](../specifications.md#aleobft) を採用しています。この仕組みはプルーフ・オブ・ステーク（PoS）を組み合わせ、バリデータがシステム全体の完全性と性能維持に貢献した対価を得られるように設計されています。

Aleo ネットワークは次の 3 種類の参加者によって運営・維持されています。  
- **ステーカー** — ステークした Aleo クレジット（AC）を委任し、より多くのバリデータを参加させてネットワークのコンセンサスに関与します。  
- **プローバー** — 専用ハードウェアを用いて証明を生成し、コインベースパズルを解くことでネットワークのセキュリティに貢献します。
- **バリデータ** — ゼロ知識（ZK）証明を検証してトランザクションを承認し、ネットワークのコンセンサスプロセスに積極的に参加します。

これらのグループに関するよくある質問は [FAQ](https://aleo.org/faq/) を参照してください。

誰でも一定期間 Aleo クレジットをロックすることでステーカーになり、Aleo ネットワークのセキュリティを支援できます。ステークの最低金額は 1 AC ですが、報酬を得られるのは 10 AC 以上をステークした場合に限られます。ステーカーは、自身のステークをバリデータに委任することでバリデータ参加のハードルを下げる役割も担います。  

**ステーカー**の詳細は[こちら](./staking.md)をご覧ください。  

プローバーは、PoSW（Proof-of-Succinct-Work）コインベースパズルに対する SNARK 証明の解を生成するため、専用の GPU や CPU を稼働させる必要があります。報酬は、パズルの解をどれだけ効率的かつ効果的に生成できたかによって決まります。プローバーはブロックを生成しませんが、証明生成の効率化、コスト削減、プログラム実行のレイテンシ低減に貢献するようインセンティブ設計されています。  

**プローバー**の詳細は[こちら](./provers.md)をご覧ください。  

バリデータは AleoBFT（後述）を通じてネットワークの安全性を確保する重要な役割を担い、参加には最低 1,000 万 AC のステークが必要です。主な機能は、トランザクションをブロックへ含める前に ZK 証明を検証し、取引内容を確認することです。

**バリデータ**の詳細は[こちら](./validators.md)をご覧ください。   



## AleoBFT
AleoBFT は新しいハイブリッド型コンセンサスアーキテクチャです。Narwhal と Bullshark から着想を得た DAG ベースの BFT プロトコルで、ネットワークのライブネス維持に取り組むバリデータと、Aleo エコシステム全体の証明能力を拡張するプローバーの双方にインセンティブを与えます。

バリデータが各ブロックでコンセンサスに達すると AleoBFT は即時ファイナリティを保証します。これにより、バリデータはノードの安定性向上を享受できるだけでなく、アプリケーション開発者やユーザーにも滑らかな体験を提供します。また、この性質は他のエコシステムとの相互運用性を容易にします。

AleoBFT のプローバーは ZK 証明の計算基盤となる存在で、Proof of Succinct Work（PoSW）として知られるコインベース証明を解き生成することでコインベース報酬の一部を受け取ります。この仕組みは、プローバー自身が 1,000 万 AC を蓄積してステークし、バリデータへ移行する動機にもつながります。報酬分配が広がることで、Aleo ネットワークは証明能力の向上とさらなる分散化・スケーリングを達成し、検閲耐性の強化にも寄与します。

:::info
詳しい技術仕様は [AleoBFT 仕様書](https://developer.aleo.org/specs/aleobft.pdf) を参照してください。
:::

## Bullshark and Narwhal

### Bullshark
Bullshark は DAG（有向非巡回グラフ）ベースの BFT（ビザンチン耐性）プロトコルで、ネットワーク通信層と順序付け（コンセンサス）ロジックを切り離します。各メッセージにはトランザクション群と以前のメッセージへの参照が含まれ、全メッセージが連なることで成長する DAG を構成します。メッセージが頂点、参照が辺になり、頂点は提案、辺は投票を表すことができます。

ネットワークが非同期であるため、タイミングによって各ノードで見える DAG がわずかに異なることがあります。それでも各バリデータは追加のメッセージ送信なしに、手元の DAG から全ての頂点（ブロック）を完全に順序付けできます。

ここで利用される DAG はラウンド制で、各頂点にラウンド番号が割り当てられ、1 ラウンドあたり最大 `n` 個の頂点を持ちます。各バリデータは毎ラウンド 1 メッセージをブロードキャストし、少なくとも `n − f` 個の前ラウンドのメッセージを参照します。`n` はバリデータ総数、`f` はビザンチンノード数です。以下は `n = 4`、`f = 1` の例です。

![DAG1](./images/DAG1.png)
Diagram 1: Round-based DAG  
Image from https://decentralizedthoughts.github.io/2022-06-28-DAG-meets-BFT/

### Ordering Logic
偶数ラウンドごとにあらかじめ決められたリーダーが選出され、その頂点をアンカーと呼びます。一般的なリーダーベースのプロトコルとは異なり、アンカーは毎ラウンドデータを配布したり全作業を担ったりするわけではなく、十分な票（`2f + 1`、この例では 3）を集めてはじめて自分の因果履歴をコミットします。  

奇数ラウンドの各頂点は、直前ラウンドのアンカーへ 1 票を投じられます。アンカーは `f + 1`（この例では 2）票を得るとコミットされます。アンカーがコミットされると、その因果履歴が決定的なルールで順序付けられます。図 2 の緑枠はアンカー 2（A2）の因果履歴です。図 3 では A2 が 3 票でコミットされていますが、正直なバリデータがブロードキャストしたトランザクションは最終的に他の正直なバリデータにも届くという DAG の性質により、1 票しか得られなかった A1 もコミットされることが示されています。

![DAG2](./images/DAG2.png)
Diagram 2: Anchor and casual history  
Image from https://decentralizedthoughts.github.io/2022-06-28-DAG-meets-BFT/

![DAG3](./images/DAG3.png)
Diagram 3: Commit rule  
Image from https://decentralizedthoughts.github.io/2022-06-28-DAG-meets-BFT/

ネットワークが非同期であるため、ノードによって DAG のローカルビューは異なる場合があります。あるバリデータが A1 をコミットしていなくても、他のバリデータはコミットしているかもしれません。図 4 に示すように、バリデータ 2 はアンカー A1 に 2 票（`f + 1`）が集まっていると判断し、バリデータ 1 がまだコミットしていなくても A1 をコミットします。

![DAG4](./images/DAG4.png)
Diagram 4: Different local view  
Image from https://decentralizedthoughts.github.io/2022-06-28-DAG-meets-BFT/

アンカーをコミットするには `f + 1`（この例では 2）票が必要であり、DAG の各頂点は前ラウンドの少なくとも `n − f`（この例では 3）頂点への辺を持ちます。そのため、あるノードがアンカー A をコミットした場合、より後のラウンドのアンカーは必ず A に投票した頂点へのパスを持つことになり、ひいては A へのパスも存在します。

言い換えると、後続のアンカーからアンカー A へのパスが存在しない場合、誰も A をコミットしていないことになり、A をスキップしても安全です。図 5 は、A2 に至るパスがないためどのノードも A2 をコミットしておらず、スキップして問題ないことを示しています。

![DAG5](./images/DAG5.png)
Diagram 5: Skipping uncommitted anchor  
Image from https://decentralizedthoughts.github.io/2022-06-28-DAG-meets-BFT/

アンカーがコミットされると、バリデータは未コミットの直前アンカーへのパスがあるかを確認します。存在すれば、そのアンカーも併せてコミットします。この処理は、直前のコミット済みアンカーに到達するまで繰り返されます。図 5 では A3 がコミットされ、A3 のパス上に A1 が存在するため A1 もコミットされています。

こうしてアンカーの履歴は決定的な順序で並べられ、最終的に全順序、すなわちブロックチェーンを形成します。

![DAG6](./images/DAG6.png)
Diagram 6: Total order  
Image from https://www.youtube.com/watch?v=aW1-XcGzJ8M

### Narwhal
Narwhal は DAG ベースのメモリプール抽象化プロトコルです。提案するバリデータは、ブロック内の全トランザクションを他のバリデータへ直接送るのではなく、各ラウンドでブロックの参照または可用性証明（証明書）だけを送信します。

1 つのバリデータは複数のワーカーと 1 つのプライマリ（親プロセス）をそれぞれ独立したプロセスとして動かします。ワーカーはトランザクションを受信し、バッチ化して他バリデータの対応するワーカーへストリーム配信します。例えば、バリデータ 1 のワーカー 1 はバリデータ 2 のワーカー 1 に、バリデータ 1 のワーカー 2 はバリデータ 2 のワーカー 2 に、といった具合です。

![Narwhal](./images/Narwhal1.png)
Diagram 7: Narwhal Design  
image from https://www.youtube.com/watch?v=NGOXVSFzYdI

各ワーカーはバッチのハッシュ（ダイジェスト）をプライマリに送信します。プライマリはそのダイジェストと前ラウンドの `n - f` 件の証明書を他のバリデータへ送ります。  

各バリデータはダイジェストが同じラウンドのものか、また自分のワーカーがダイジェストに対応するトランザクションバッチを保持しているかを確認します。条件を満たしていれば、送信元プライマリへ署名を送り返して投票します。  

送信元が異なるバリデータから `n - f` 個の署名を集めると証明書が生成され、その証明書が全バリデータへ送信されます。この証明書は次ラウンドで参照として利用されます。

証明書を受け取ることは、そのブロックがダウンロード可能であることを意味します。そのため証明書は可用性証明（Proof of Availability）とも呼ばれ、データ可用性を保証します。

![Narwhal2](./images/Narwhal2.png)
Diagram 8: A round in Narwhal    
image from https://www.youtube.com/watch?v=NGOXVSFzYdI

![Narwhal3](./images/Narwhal3.png)
Diagram 9: Another view of a round   
image from https://www.youtube.com/watch?v=NGOXVSFzYdI
