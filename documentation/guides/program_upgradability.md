---
id: program_upgradability
title: Aleo におけるプログラムのアップグレード
sidebar_label: プログラムのアップグレード
---

従来のブロックチェーン開発では、1 度デプロイしたら変更できない「イミュータブルな」コントラクトが当たり前でした。これは高い安全性をもたらす一方で、バグ修正や機能追加が難しくなります。Aleo はこの課題を解決するために、アプリケーションの状態を壊さず、タイムリーかつコスト効率よくアップグレードできる枠組みを導入しました。

このフレームワークにより、Aleo の開発は静的なモデルから動的なモデルへと進化し、アプリケーションを継続的に改善できます。デプロイ後にプログラムロジックを書き換えられるため、脆弱性の修正や機能強化、ユーザー要件への対応を大掛かりなステート移行なしで行えます。開発者はアップグレードを念頭に置いた設計を初期段階から行い、プログラムのライフサイクルを考慮する必要があります。

本ガイドでは、この機能の仕組みとセキュリティ面の影響、そして遵守すべきルールについて解説します。

## コンストラクタ

`constructor` は、アップグレードを有効化・管理する唯一の入り口となる特別なコードブロックです。初回デプロイ時に `constructor` を含めることが、プログラムをアップグレード可能にする唯一の方法です。アップグレード可能な仕組みが有効になった後にデプロイされるプログラムは、すべて**空でない**コンストラクタを持たなければなりません。`constructor` 内のロジックは自由に設計でき、アップグレード手順に柔軟性を持たせられます。

その挙動は厳格に定義されています。

* **実行コンテキスト:** `constructor` のロジックは、初回デプロイおよびそれ以降のアップグレードといったデプロイイベント時にのみ AVM (Aleo Virtual Machine) によってオンチェーンで実行されます。通常の関数呼び出しでは実行されません。
* **不変性:** `constructor` 内のロジックは恒久的です。プログラムをデプロイすると、アップグレードで `constructor` を変更・削除することはできません。これにより、アップグレードルールが安定し、迂回できないようになります。
* **トランザクションの最終性:** `constructor` はすべてのデプロイやアップグレードにおける最終チェックとして機能します。ロジックが停止した場合（`assert` が失敗するなど）、デプロイまたはアップグレードのトランザクション全体が失敗します。アップグレード条件を強制する強力な手段といえます。

:::note
可変性は、最初から明示的に設計へ組み込む必要がある機能です。
:::

## プログラムメタデータのオペランド

`constructor` に加えて、AVM は 3 つの新しいメタデータオペランドを提供します。これらはオンチェーンで検証可能なプログラムの状態情報を提供し、安全なアップグレードルールを記述するのに役立ちます。

**`<PROGRAM_ID>/edition` | `edition`**  
  * **概要:** プログラムのバージョン番号として機能する符号なし 16 ビット整数 (`u16`)。  
  * **ルール:** 初回デプロイでは必ず `0u16` でなければなりません。正当なアップグレードごとに必ず 1 ずつ増加します。  
  * **使用可能な範囲:** `finalize` スコープ内のみで利用できます。

**`<PROGRAM_ID>/checksum` | `edition`**  
  * **概要:** プログラム文字列の SHA3-256 ハッシュを表す 32 バイト配列 (`[u8; 32u32]`) で、コードの指紋に相当します。  
  * **ルール:** アップグレード可能なプログラムをデプロイする際は必須で、デプロイされたコードが期待どおりであることを検証します。  
  * **使用可能な範囲:** `finalize` スコープ内のみで利用できます。

**`<PROGRAM_ID>/program_owner` | `program_owner`**  
  * **概要:** デプロイトランザクションを送信したアカウントの `address`。  
  * **ルール:** アップグレード可能なプログラムをデプロイする際には必須です。  
  * **使用可能な範囲:** `finalize` スコープ内のみで利用できます。

:::info
これら 3 つのオペランドが `finalize` スコープでのみ利用できる点は重要なセキュリティ設計です。所有者、バージョン、コード内容に基づくアップグレードの認可ロジックを公開状態遷移としてオンチェーンで実行・検証させることで、オフチェーンの証明コンテキストで偽装されるのを防ぎます。
:::

## アップグレードにかかるコスト

`constructor` を実行するにはネットワーク資源が必要で、コストが発生します。基本的なコストモデルは通常の `finalize` ブロックと同じですが、大きな係数（現在は 100 倍）が掛かります。

コストが高めに設定されているのには 2 つの理由があります。1 つはデプロイトランザクションの重要性を反映するため、もう 1 つは `constructor` のロジックをシンプルで効率的に保つインセンティブを与えるためです。これにより、変更不可能なクリティカルコードでバグが発生するリスクを下げられます。

## アップグレードのルール

Aleo プロトコルは、有効なプログラムアップグレードの条件を厳格に定めています。新しいロジックを導入する必要と、既存ユーザーや依存プログラムに破壊的な影響を与えないことのバランスを取っています。

AVM は、追加・変更・禁止事項に関する明確なルールを持っています。

アップグレードで**できること**:
* **ロジックの変更:** 既存の `function` や `finalize` ブロックの内部実装を変更できます。バグ修正や性能改善の主な手段です。
* **新しい要素の追加:** 追加の `struct`、`record`、`mapping`、`function`、`closure` を定義して機能を拡張できます。
* **新しい import:** 外部プログラムを新たに import できます。

アップグレードで**できないこと**:
* **インターフェースの変更:** 既存 `function` の `input` / `output` シグネチャ、または `finalize` ブロックの `input` インターフェースを変更できません。後方互換性を守るためです。
* **クロージャの変更:** 既存 `closure` のロジックは変更できません。変更すると、それに紐づく証明鍵と検証鍵が無効化され、ユーザー資産が破損する恐れがあります。
* **データ構造の変更:** 既存の `struct`、`record`、`mapping` を変更・削除できません。既存のプログラム状態を保護するためです。
* **要素の削除:** どの種類のプログラム要素も削除できません。

クイックリファレンスは以下のとおりです。

| プログラム要素 | 削除 | 変更 | 追加 |
| :--- | :---: | :---: | :---: |
| `import` | ❌ | ❌ | ✅ |
| `struct` | ❌ | ❌ | ✅ |
| `record` | ❌ | ❌ | ✅ |
| `mapping` | ❌ | ❌ | ✅ |
| `closure` | ❌ | ❌ | ✅ |
| `function` | ❌ | ✅ (ロジック) | ✅ |
| `finalize` | ❌ | ✅ (ロジック) | ✅ |
| `constructor` | ❌ | ❌ | ❌ |

## オンチェーンでの検証

`Deployment` トランザクションが送信されると、AVM は一連の検証を行います。

**1. 新規プログラムのデプロイ (`edition` が 0 の場合):**  
アップグレード可能な新規プログラムについて AVM は次を確認します。[1]
* `constructor` を含んでいること。
* `edition` が `0u16` であること。
* `checksum` が存在し、プログラムコードのハッシュと一致していること。
* `program_owner` が存在し、トランザクション送信者と一致していること。
* そのプログラム ID が未使用であること。

**2. プログラムのアップグレード (`edition` が 0 より大きい場合):**  
アップグレードではより多くの検証が行われます。[1]
* そのプログラム ID がすでに存在していること。
* 新しい `edition` が旧バージョンの `edition + 1` になっていること。
* コードの変更がすべてルールに従っていること（例: 関数シグネチャを変えていない）。
* アップグレード対象の既存プログラムに**すでに `constructor` が存在すること**。

特に最後のチェックが仕組みの要です。アップグレードできるのは、最初からアップグレードを想定して設計されたプログラムのみという保証になります。

## セキュリティとベストプラクティス

アップグレード機能は強力ですが、可変性に起因するリスクを伴います。プログラムをアップグレード可能にするということは、その権限を安全に管理する責任を負うことでもあります。悪意ある、あるいは乗っ取られた開発者がアップグレードを利用して脆弱性や資金流出、資産ロックを引き起こす可能性もゼロではありません。

ユーザーがアップグレード可能なプログラムを利用する場合、現在のコードだけでなく、将来的にコードを変更するガバナンス手続きも信頼する必要があります。

### コンストラクタは不変

アップグレード可能なプログラムにおける最重要のセキュリティ要素は `constructor` です。`constructor` のロジックは不変であり、将来のアップグレードでも変更できません。

`constructor` にバグがあると永続的に修正できません。誤った管理者アドレスをハードコードしたり、投票ロジックに欠陥があると、制御権を失ったりガバナンスが成立しなくなる恐れがあります。`constructor` はミッションクリティカルなコードとして扱い、デプロイ前に慎重な監査を行ってください。

### 設計パターン

`constructor` で安全性・信頼性を高めるさまざまなパターンを活用できます。

* **マルチシグによるガバナンス:** アップグレードに複数署名を必須とし、単一障害点を排除する。
* **タイムロック付きアップグレード:** アップグレードの告知から実行までに猶予期間を設け、ユーザーが変更内容を確認し離脱できるようにする。
* **プログラムの凍結 (ossification):** `constructor` にメカニズムを組み込み、将来のアップグレードを恒久的に禁止できるようにする。たとえば「edition が 0 のときだけ許可する」といった条件にする。
* **依存関係の固定:** アップグレード可能な別プログラムへ依存している場合は、`finalize` ブロックで `edition` をチェック（例: `assert.eq child.aleo/edition 0u16;`）し、特定バージョンに固定できます。依存側が破壊的な変更をしても影響を受けにくくなりますが、新しい正当なバージョンを採用するには自分のプログラムもアップグレードする必要があります（詳細は[依存関係の管理](#managing-dependencies)を参照）。

## 例

`constructor` を使えば、多彩なガバナンスモデルを実装できます。以下では AVM が実行する低レベル言語である Aleo Instructions を用いて、代表的なアップグレードパターンをコメント付きで紹介します。  
Leo 言語での記述方法については、[Leo ドキュメント](https://github.com/ProvableHQ/leo-docs-source/blob/6ec29db64ef4620b9bfd86a876818f260202c230/documentation/guides/03_program_upgradability.md)を参照してください。

### アップグレード不可のプログラム

一切アップグレードできないプログラムの例です。

```aleo
program noupgrade_example.aleo;

constructor:
    // このアサーションは edition が 0 であることを確認します。
    // 初回デプロイでは成立しますが、アップグレード時には edition が 0 より大きくなるため
    // アサーションが失敗し、アップグレードトランザクションが停止します。
    assert.eq edition 0u16;

//... その他のプログラムロジック...
```

`constructor` が `edition 0` でのデプロイしか許さないため、アップグレードは不可能になります。

### 管理者によるアップグレード

ハードコードした 1 つの管理者アドレスにアップグレード権限を限定する例です。

```aleo
program admin_example.aleo;

constructor:
    // 今回デプロイしているアドレスがあらかじめ定義した ADMIN_ADDRESS と一致するか検証します。
    // 重要: このアドレスはハードコードされ、デプロイ後に変更できません。
    assert.eq program_owner <ADMIN_ADDRESS>;

//... その他のプログラムロジック...
```

このパターンでは `program_owner` オペランドを使って、デプロイしたアドレスが指定した管理者であることを確認します。シンプルですが、管理者鍵を失うと永遠に制御を取り戻せません。

### 管理者を差し替えられる事前承認アップグレード

管理者を変更可能にし、アップグレード対象の `checksum` をあらかじめ登録させる例です。

```aleo
program preapproved_example.aleo;

mapping admin:
    key as boolean.public;
    value as address.public;

mapping expected:
    key as boolean.public;
    value as [u8; 32u32].public;

constructor:
    // edition が 0（初回デプロイ）の場合は初期管理者を設定します。
    branch.neq edition 0u16 to upgrade_check;
    set <ADMIN_ADDRESS> into admin[true]; // 初期管理者アドレスに置き換えてください。
    branch.eq true true to end;

    // それ以降のアップグレードでは、事前承認されたチェックサムと一致するか検証します。
    position upgrade_check;
    get expected[true] into r0;
    assert.eq checksum r0;

    position end;

// この関数は現在の管理者が次回アップグレード用のチェックサムを設定するためのものです。
function set_expected:
    input r0 as [u8; 32u32].public;
    async set_expected self.caller r0 into r1;
    output r1 as foo.aleo/set_expected.future;

finalize set_expected:
    input r0 as address.public; // 呼び出し元
    input r1 as [u8; 32u32].public; // 設定するチェックサム
    // 現在の管理者を取得
    get admin[true] into r2;
    // 呼び出し元が管理者か確認
    assert.eq r0 r2;
    // 次回アップグレードのチェックサムを保存
    set r1 into expected[true];
```

このパターンでは、管理者と次回許可するアップグレードの `checksum` をオンチェーンの `mapping` に保存します。`set_expected` 関数により管理者が次のアップグレードを承認できます。管理者を変更する関数も追加すれば、ハードコード方式より柔軟に運用できます。

### DAO によるアップグレード

DAO コントラクトがアップグレードを管理する例です。

```aleo
import governor.aleo;

program dao_example.aleo;

constructor:
    // edition が 0（初回デプロイ）のときはアップグレードチェックをスキップします。
    branch.eq edition 0u16 to end;

    // 'governor.aleo' が承認済みチェックサムをマッピングに保持している DAO コントラクトであると仮定します。
    get governor.aleo/approved_checksum[true] into r0;

    // デプロイしようとしているプログラムのチェックサムが
    // DAO が承認したチェックサムと一致することを確認します。
    assert.eq checksum r0;

    position end;

//... その他のプログラムロジック...
```

このパターンではアップグレード権限を別プログラムに委任します。`constructor` が DAO コントラクトから有効な `checksum` を取得し、アプリケーションロジックとガバナンスを切り離します。

### タイムロック付きアップグレード

**目的:** 特定のブロック高に達するまでアップグレードを許可しない。

```aleo
program timelock_example.aleo;

constructor:
    // edition が 0（初回デプロイ）のときは時間制限のチェックをスキップします。
    gt edition 0u16 into r0;
    branch.eq r0 false to end_then_0_0;

    // それ以外の場合は、現在のブロック高が定めた値以上であることを確認し
    // アップグレードにタイムロックをかけます。
    gte block.height <BLOCK_HEIGHT> into r1;
    assert.eq r1 true;
    
    branch.eq true true to end_otherwise_0_1;
    position end_then_0_0;
    position end_otherwise_0_1;

//... その他のプログラムロジック...
```

* **メカニズム:** この `constructor` は `block.height` を利用して時間的な制約を課し、アップグレード前に「クールダウン期間」を設けます。[1]

### プログラムの凍結 (Ossification)

管理者が将来のアップグレードを恒久的に禁止できる例です。

```aleo
program ossification_example.aleo;

mapping is_locked:
    key as boolean.public;
    value as boolean.public;

constructor:
    // すべてのアップグレードで実行されます。is_locked フラグが true の場合、
    // アサーションが失敗してアップグレードが停止します。
    contains is_locked[true] into r0;
    assert.eq r0 false;

    //... ここに管理者チェックなど追加のロジックを記述できます...

//... 管理者が is_locked[true] を true に設定する関数など、他のロジックを続けます。
```

*このパターンでは `mapping` を片道フラグとして利用します。`true` に設定すると、以降のアップグレードは `constructor` で拒否されます。*

### 依存関係の管理

依存しているプログラムの予期しないアップグレードから身を守るため、特定バージョンに固定する例です。

```aleo
import child.aleo;

program parent.aleo;

constructor:
    //... 依存先がアップグレードした場合に備え、自分側にもアップグレードの仕組みを用意しておくべきです。

function some_function:
    //... child.aleo の関数を呼び出すロジック
    call child.aleo/some_child_function...;

finalize some_function:
    //...
    // finalize スコープ内で依存先の edition をチェックします。
    // このオペランドは finalize 内でしか利用できません。
    assert.eq child.aleo/edition 0u16;
    //...

//... その他のプログラムロジック...
```

この防御的パターンは `constructor` ではなく `finalize` ブロックで使用し、依存先の `edition` を検証します。破壊的変更から身を守れますが、依存先の新しい正当なバージョンを利用するには自分のプログラムもアップグレードする必要があります。

:::warning[important]
このパターンを使う場合、依存先のアップグレードで自分の機能がロックされる可能性に備えて、自分のプログラムもアップグレード可能にしておくことを推奨します。
:::

## クイックリファレンスサマリー

| 概念 | 仕組み | 重要なポイント |
| :--- | :--- | :--- |
| **アップグレードの有効化** | 新しいプログラムはすべて、どのようにアップグレードするかを明示する必要がある。 | 自身のアップグレード方針を明確にすること。 |
| **レガシープログラムの扱い** | アップグレード機能導入前にデプロイされたプログラムには `constructor` がない。 | 恒久的にアップグレード不可。 |
| **アップグレード権限** | 不変の `constructor` ロジックにより決まる。 | `constructor` がガバナンスそのもの。ロジックは永久に固定される。 |
| **主なリスク** | `constructor` 自体が不変であり修正できない。 | `constructor` のバグは永続的。徹底した監査が必須。 |
| **有効な変更内容** | `function` / `finalize` のロジック変更、新しい要素の追加など。 | 既存のインターフェースやデータ構造は変更・削除できない。 |
| **プログラムの凍結** | `constructor` にアップグレード権限を永久に破棄するロジックを組み込む。 | 長期的にユーザーへ安心感を与えるため、イミュータブル化の道も提供する。 |

## アップグレード機能導入前のプログラム

アップグレード機能が導入される前に Aleo ネットワークへデプロイされたプログラムは、今後も永久にアップグレードできません。

AVM の検証ロジックでは、既存プログラムをアップグレードするには `constructor` が必須です。レガシープログラムが作成された当時は `constructor` という概念が存在しなかったため、これらのプログラムには含まれていません。そのためアップグレードを試みても AVM の検証で必ず失敗します。

:::note
1. `constructor` を持つプログラムはアップグレード可能です。  
2. `constructor` を持たないプログラムは永久にアップグレードできません。
:::

### マイグレーションを行わない方針

初期の提案では、レガシープログラムの所有者が 1 度だけ `constructor` を追加できる「一度限りのマイグレーション」を検討していました。

**しかしこの移行案は正式に撤回され、プロトコルとしてサポートされていません。** 既にデプロイ済みのプログラムに後から `constructor` を追加する手段はありません。

レガシーアプリケーションに新機能の追加やバグ修正が必要な場合は、まったく新しいプログラムをデプロイし、ユーザーがステートや資産を移行できる経路を用意する必要があります。
